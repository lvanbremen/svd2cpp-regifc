
// SPDX-License-Identifier: MPL-2.0

// File generated by svd2cpp-regifc version 1.1
//
// Source SVD file information:
// Name: {{device.name}}
// Version: {{device.version}}
// Description: {{device.description}}
//
{% macro render_register(register, struct_name, struct_index, index_list=None) %}
// {{register.description}}
struct {{struct_name}} : public Register<std::uint{{register.size}}_t, {{"0x%0*X" | format(register.size // 4, register.reset_value)}}, {{struct_name}}> {
{% for field in register.fields %}
    using {{field.name}}Field = VolatileField<{{struct_name}}, {{field.bit_offset}}, {{field.bit_width}}>;
    // {{field.description}}
    auto {{field.name}}() { return {{field.name}}Field{ *this, val_vol }; }
{% endfor %}

    struct StableAccess : public StableAccessBase<reg_type> {
        StableAccess(volatile reg_type& val_vol__, reg_type val_copy__) : StableAccessBase<reg_type>(val_vol__, val_copy__) {}
{% for field in register.fields %}
        auto {{field.name}}() { return StableField<decltype(*this), {{field.bit_offset}}, {{field.bit_width}}>{ *this, val_copy }; }
        auto {{field.name}}() const { return ConstField<decltype(*this), {{field.bit_offset}}, {{field.bit_width}}>{ *this, val_copy }; }
        // {{field.description}}
        template <typename Targ> auto& {{field.name}}(Targ val) { return {{field.name}}().mod(val); }
{% endfor %}
    };
{% if index_list %}

    enum Index {
{% for index_val in index_list %}
        {{index_val | cvar}},
{% endfor %}
    };
{% endif %}
{% if struct_index %}
} {{struct_index}};
{% else %}
};
{% endif %}

{% endmacro %}
{% macro render_registers(registers, base_name) -%}
{% for register in registers %}
{% if loop.index0 == 0 %}
{% set prev_address_end = 0 %}
{% else %}
{% set prev_address_end = loop.previtem.address_offset + loop.previtem.size // 8 %}
{% endif %}
{% if prev_address_end <= register.address_offset %}
{% if prev_address_end != register.address_offset %}
  private:
    std::uint8_t _reserved_{{"%X" | format(prev_address_end)}}[{{register.address_offset - prev_address_end}}];
  public:

{% endif %}
{% if 'registers' in register %}
    // {{register.description}}
{% set cluster_name = register.name.replace('[%s]', '').replace('%s', '') %}
    {{base_name}}{{cluster_name}}Interface {{cluster_name}}[{{register.dim}}];
{% else %}
    {{ render_register(register, register.name|string + 'Reg', register.name) | indent -}}
{% endif %}
{% endif %}
{% endfor %}
{% endmacro %}
{% macro render_interface(registers, interface_name, description, dim_index = None) %}
{# First render all interfaces recursively #}
{% for register in registers %}
{% if 'registers' in register %}
{% set cluster_name = interface_name + register.name.replace('[%s]', '').replace('%s', '') %}
{{ render_interface(register['registers'], cluster_name, register.description, register.dim_index) -}}
{% endif %}
{% endfor %}
{% if registers | length == 1 and registers[0].name == None %}
{# No register name available, and it is the only register, don't render as group but just as repeating register #}
{{ render_register(registers[0], interface_name + 'Interface', '', dim_index) -}}
{% else %}
// {{description}}
struct {{interface_name}}Interface {
{{ render_registers(registers, interface_name) -}}
{% if dim_index %}

    enum Index {
{% for index_val in dim_index %}
        {{index_val | cvar}},
{% endfor %}
    };
{% endif %}
};
{% endif %}
{% endmacro %}

#include "{{device.name.lower()}}-regifc.h"
#include "common-regifc.h"

{% for group in groups.values() %}
{{ render_interface(group.registers, group.name, group.description) }}
{% for peripheral in group.peripherals %}
#define {{peripheral.name}}_IFC_ADDR {{"0x%0*X" | format(device.width // 4, peripheral.base_address)}}
#define {{peripheral.name}}_IFC      (*({{group.name}}Interface*)({{peripheral.name}}_IFC_ADDR))
{% endfor %}

{% endfor %}
