
// SPDX-License-Identifier: MPL-2.0

#ifndef common_svd2cpp_h
#define common_svd2cpp_h

#include <cstdint>
#include <type_traits>
#include <limits>

template <typename Treg, typename Tval, unsigned int _Offset, unsigned int _Width>
struct BaseField {
    // Define some useful field attributes
    using reg_type = typename std::remove_reference_t<Treg>::reg_type;
    static auto const reg_bits = std::numeric_limits<reg_type>::digits;

    // Define mask for this field
    static_assert(_Width > 0, "Width must be non-zero");
    static_assert((_Offset + _Width) <= reg_bits, "Offset + Width must not exceed reg_type value size");
    static reg_type const constexpr Offset = _Offset;
    static reg_type const constexpr Width = _Width;
    static reg_type const constexpr Mask = (((Offset + Width) == reg_bits) ? 0 : (reg_type(1) << (Offset + Width))) - (1U << Offset);

    // Create accessors for underlying data of this field
    Treg& reg_;
    Tval& val_;

    BaseField(Treg& reg__, Tval& val__) : reg_(reg__), val_(val__) {}

  protected:
    // Modify functions are internal, exposed with different signature by either VolatileField or StableField
    template <typename Targ, class = typename std::enable_if<std::is_integral<Targ>::value>::type>
    void mod_internal(Targ val_set, typename std::enable_if_t<std::is_integral_v<Targ>>* = 0) {
        if (__builtin_constant_p(val_set)) {
            // Constant input, write value to fold to immediate instruction
            val_ = (val_ & ~Mask) | ((val_set << Offset) & Mask);
            return;
        }
        // Force use BFI instruction
#if defined(__ARM_ARCH_ISA_A64) && __ARM_ARCH_ISA_A64
        if (reg_bits > 32) {
            asm (
            // More than 32 bits, use X type register
                "bfi     %x[res], %x[set], %[off], %[len]"
                : [res]"=r" (val_)
                :       "r" (val_),
                  [set] "r" (val_set), [off]"i" (Offset), [len]"i" (Width)
            );
        } else
#endif
        {
            asm (
#if defined(__ARM_ARCH_ISA_A64) && __ARM_ARCH_ISA_A64
            // Use W type register on 64-bit systems
                "bfi     %w[res], %w[set], %[off], %[len]"
#else
            // Use any register on 32-bit systems
                "bfi     %[res], %[set], %[off], %[len]"
#endif
                : [res]"=r" (val_)
                :       "r" (val_),
                  [set] "r" (val_set), [off]"i" (Offset), [len]"i" (Width)
            );
        }
    }

    void set_internal() {
        val_ |= Mask;
    }
    void clr_internal() {
        val_ &= ~Mask;
    }

  public:
    // Read access functions for this field
    template <typename Tauto>
    operator Tauto() const {
        static_assert((not std::is_same_v<Tauto, bool>) || (Width == 1), "Boolean return value is only valid for single bit fields");
        static_assert((std::numeric_limits<Tauto>::digits == 0U) // Temporary values are always valid
                          || std::numeric_limits<Tauto>::digits >= Width, "Destination type too small, use an explicit cast to discard additional bits");
        return Tauto((val_ & Mask) >> Offset);
    }
    auto get() const {
        if constexpr (Width == 1) {
            // For auto values of width 1, automatically convert to boolean
            return static_cast<bool>(this->operator reg_type());
        } else {
            // For other widths, use the register type
            return this->operator reg_type();
        }
    }
};

// Specialization of BaseField with RMW (volatile) access
template <typename Treg, unsigned int Offset, unsigned int Width>
struct VolatileField : public BaseField<Treg, volatile typename std::remove_reference_t<Treg>::reg_type, Offset, Width> {
    using Base = BaseField<Treg, volatile typename std::remove_reference_t<Treg>::reg_type, Offset, Width>;

    VolatileField(Treg& reg__, volatile typename std::remove_reference_t<Treg>::reg_type& val__) : Base(reg__, val__) {}

    // Expose as RMW, since access is volatile, it implicitly performs a read and write
    template <typename Targ, class = typename std::enable_if<std::is_integral<Targ>::value>::type>
    void rmw(Targ val_set, typename std::enable_if_t<std::is_integral_v<Targ>>* = 0) {
        Base::mod_internal(val_set);
    }
    template <typename Targ>
    void rmw(Targ val_set, typename std::enable_if_t<!std::is_integral_v<Targ> && std::is_enum_v<Targ>>* = 0) {
        rmw(static_cast<std::underlying_type_t<Targ>>(val_set));
    }

    // Do not return reg_, call chaining is ill-advised
    void set() {
        Base::set_internal();
    }
    void clr() {
        Base::clr_internal();
    }
};

// Specialization of BaseField with modify-only (non-volatile) access
template <typename Treg, unsigned int Offset, unsigned int Width>
struct StableField : public BaseField<Treg, typename std::remove_reference_t<Treg>::reg_type, Offset, Width> {
    using Base = BaseField<Treg, typename std::remove_reference_t<Treg>::reg_type, Offset, Width>;

    StableField(Treg& reg__, typename std::remove_reference_t<Treg>::reg_type& val__) : Base(reg__, val__) {}
    
    // Expose as modify-only, no implicit read or write is performed
    template <typename Targ>
    auto& mod(Targ val_set, typename std::enable_if_t<std::is_integral_v<Targ>>* = 0) {
        Base::mod_internal(val_set);
        return Base::reg_;
    }
    template <typename Targ>
    auto& mod(Targ val_set, typename std::enable_if_t<!std::is_integral_v<Targ> && std::is_enum_v<Targ>>* = 0) {
        return mod(static_cast<std::underlying_type_t<Targ>>(val_set));
    }

    // Stable call chaining is desired, return reg_
    auto& set() {
        Base::set_internal();
        return Base::reg_;
    }
    auto& clr() {
        Base::clr_internal();
        return Base::reg_;
    }
};

template <typename Tval, Tval reset_value, typename Reg>
struct Register {
    using reg_type = Tval;
    static auto const reg_bits = std::numeric_limits<reg_type>::digits;
    volatile Tval val_vol;
    
    auto read() {
        return typename Reg::StableAccess{ val_vol, val_vol };
    }
    auto init(Tval val_init = reset_value) {
        return typename Reg::StableAccess{ val_vol, val_init };
    }
    void write(Tval val_write) {
        val_vol = val_write;
    }
    void clear() {
        val_vol = 0;
    }

    void set(reg_type mask) {
        val_vol |= mask;
    }
    void clr(reg_type mask) {
        val_vol &= ~mask;
    }

    template <typename Targ, class = typename std::enable_if<std::is_integral<Targ>::value>::type>
    void rmw(reg_type offset, reg_type mask, Targ val_set, typename std::enable_if_t<std::is_integral_v<Targ>>* = 0) {
        rmw_internal(offset, mask, val_set);
    }
    template <typename Targ>
    void rmw(reg_type offset, reg_type mask, Targ val_set, typename std::enable_if_t<!std::is_integral_v<Targ> && std::is_enum_v<Targ>>* = 0) {
        rmw(offset, mask, static_cast<std::underlying_type_t<Targ>>(val_set));
    }

  protected:
    void rmw_internal(reg_type offset, reg_type mask, reg_type val_set) {
        // Width and offset are not constant, unable to use BFI here
        val_vol = (val_vol & ~mask) | ((val_set << offset) & mask);
    }

  private:
    // Delete unwanted operators
    Register(Register const&) = delete;
    Register& operator=(Register const&) = delete;
};

template <typename Tval>
struct StableAccessBase {
    using reg_type = Tval;
    volatile Tval& val_vol;
    Tval val_copy;

    StableAccessBase(volatile Tval& val_vol__, Tval val_copy__) : val_vol(val_vol__), val_copy(val_copy__) {}

    operator Tval() {
        return val_copy;
    }
    void write() {
        val_vol = val_copy;
    }

  private:
    // Delete unwanted operators
    StableAccessBase(StableAccessBase const&) = delete;
    StableAccessBase& operator=(StableAccessBase const&) = delete;
};

#endif // common_svd2cpp_h
