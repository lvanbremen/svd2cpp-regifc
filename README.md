# svd2cpp
Convert CMSIS System View Description files to a modern C++ register interface with efficient data access functions


## Introduction
By default, ARM provides SVDConv to generate CMSIS-compliant device header files.
While the simplicity and configurability of this tool is beautiful, all it does is generate structs and definitions, where the user is responsible for correctly accessing the registers.
Accessing registers in this way is error prone, leads to hard to read code, and the resulting binary is sometimes efficient at best.

This svd2cpp converter utility tries to tackle all these problems, by instead converting the SVD to a modern C++ interface, which is easily optimized in perfect assembly.
Checkout the paragraph 'interface', for more information on what real code using this interface would look like.
See the paragraph 'efficiency' for a real-world comparison of the compiler output between the 'old school' interface and this modern interface.
After being convinced, go to the 'usage' paragraph to learn how to use the tool.
Finally, in the 'license & contribution' paragraph, there is a short word on how this tool can be used in your own (commercial) project.

## Interface
### Design intent
The code generated by this library tries to mimick the look and feel of the C++ standard library and should feel natural for any seasoned or starting developer.
Furthermore, the interface makes it easy to do the 'right' thing, while it is difficult to do the 'wrong' thing.
Each register access is designed around the Read-Modify-Write (RMW) pattern, where 'modify' can be done multiple times if multiple fields are to be altered.
Convenience methods are built on top of this RMW pattern to make small changes simple.

### Usage example
Lets stop all the babbling and jump right into a real-world example to show you the interface.
I am assuming you are familiar with the SVD files and the register access code that is usually available.
If you don't know what I'm talking about, head over to one of the numerous tutorials on SVD files.

Lets assume we have a hypothetical I2C peripheral (note that this is a slimmed down version of the example STM32L5 I2C1).
This peripheral has a Configuration Register (CR), which has the following fields:

 * SADD: an 10 bit Slave Address
 * RD_WRN: Transfer direction (1 = read, 0 = write)
 * NBYTES: Number of bytes to communicate
 * PE: Peripheral Enable

The code to first enable this peripheral, configure an address and number of bytes to transmit, and finally reading back the number of bytes would look as follows:

```
std::uint32_t i2c_transmit(I2cInterface& i2c, std::uint8_t address, std::uint16_t length) {
    // Set the Peripheral Enable bit first to allow further access
    i2c.CR.PE().set();

    // Read-Modify-Write cycle to efficiently configure the required fields
    i2c.CR.read()          // Read register once
          .SADD(address)   // Modify address (shorthand for cr.SADD().mod(address))
          .NBYTES(length)  // Modify number of bytes (shorthand for cr.NBYTES().mod(length))
          .RD_WRN().clr()  // Clear RD_WRN for transmit (explicit way of writing RD_WRN(0))
          .write();        // Write result to register (shorthand for i2c.cr.write(cr))

    // Retrieve the SADD value
    return i2c.CR.NBYTES();
}
```

And thats it! Check out the paragraph 'efficiency' for the emitted assembly belonging to this interface and be convinced that this is both the most readable and most efficient way to access registers from now on.

### Compared to define interface
Imagine the interface emitted by SVDConv (or check it out in the github repository of [ST](https://github.com/STMicroelectronics/cmsis-device-l5/blob/master/Include/stm32l552xx.h)).
The equivalent code for that interface would be as follows.

```
std::uint32_t i2c_transmit(I2C_TypeDef& i2c, std::uint8_t address, std::uint16_t length) {
    // Set the Peripheral Enable bit first to allow further access
    i2c.CR |= I2C_CR_PE;

    // Read-Modify-Write cycle to efficiently configure the required fields
    auto cr = i2c.CR;                                                                       // Read register once
    cr = (cr & ~I2C_CR_SADD_Msk) | ((address << I2C_CR_SADD_Pos) & I2C_CR_SADD_Msk);        // Modify address
    cr = (cr & ~I2C_CR_NBYTES_Msk) | ((length << I2C_CR_NBYTES_Pos) & I2C_CR_NBYTES_Msk);   // Modify number of bytes
    cr &= ~I2C_CR_RD_WRN;                                                                   // Clear RD_WRN for transmit
    i2c.CR = cr;                                                                            // Write result to register

    // Retrieve the SADD value
    return (i2c.CR & I2C_CR_NBYTES_Msk) >> I2C_CR_NBYTES_Pos;
}
```

The code is similar, but far from concise.
You could use convenience methods to make it easier to understand (e.g., `reg_set()`, `reg_clr()`, `reg_mod()`), but you would never get around of the mess of passing the correct macro definitions to the function.

### Compared to the bit field interface
Alternatively, SVDConv can be used to generate structs with so-called 'bit fields'.
Compared to the 'define' interface, 

### Alternative calls
Whenever multiple fields are to be modified, the explicit read-modify-write pattern in strongly recommended, as it will lead to the most efficient code.
However, when only a single field is modified, it is usually simpler to use the direct 'volatile' interface.

The following examples are all equivalent for modifying a single bit and will all emit a single read, single modify, and single write instruction (if possible):
```
i2c.CR.PE().set();
i2c.CR.PE().rmw(1);  // need to explicitly write rmw(), as no accessor is used, this will incur a read, a modify, and a write
// i2c.CR.PE(1) is intentionally not available, it would hide the RMW behavior

i2c.CR.read().PE().set().write();
i2c.CR.read().PE().mod(1).write();
i2c.CR.read().PE(1).write();
```

Multiple modify calls can easily be chained as shown in the first example.
Note, that chaining is intentionally only possible after a call to `read()`, as chaining RMW calls to a single register is inefficient.
Instead of chaining, the 'accessor' (return value of `read()`) can be stored in a temporary.
```
auto cr = i2c.CR.read();
cr.SADD(address);
cr.NBYTES(length);
cr.RD_WRN().clr();
cr.write();
```

This is as efficient as using the chaining method, no difference.
Storing the temporary may be used to interleave the calls with other code.
Note, however, that this may hurt the optimizer, so should generally be avoided.
Also, storing this 'accessor' type for longer than a scope is inefficient, instead, the register can be decayed to an `std::uint32_t` and passed to `read()` or `write()` later.
```
# Decay the value to its underlying type and write it back
std::uint32_t raw = i2c.CR.read();
i2c.CR.write(raw);

# Optionally, turn it back into an accessor, to modify a value and finally write again
i2c.CR.read(raw).PE(1).write();
```

Reading a single field is as simple as assigning it to any integral value:
```
std::uint8_t nbytes1 = i2c.CR.NBYTES();     // Explicitly choose value type
auto nbytes2 = i2c.CR.NBYTES().get();       // Or automatically get() the value, which deduces the underlying register type
// std::uint8_t sadd1 = i2c.CR.SADD();      // <- this will cause an assertion, SADD is 10 bits wide and does not fit in an 8 bit value (you could explicitly cast it to a uint8_t if really desired, just implicit casts are disabled)
// auto sadd2 = i2c.CR.SADD();              // <- this should be avoided, as it assigns the struct instead of the underlying value, which may cause weird behavior

bool flag1 = i2c.CR.RD_WRN();               // Flags can be assigned to a boolean
auto flag2 = i2c.CR.RD_WRN().get();         // Calling get() for a flag auto-deduces a boolean type
// bool no_flag = i2c.CR.SADD();            // <- this will cause an assertion, only fields of width 1 can be assigned to 
```

Instead of reading the register, it is also possible to initialize an 'accessor' with a default value.
Specifically, the `init()` function can be called with an argument to start, or no argument to start with the 'default' value as defined in the SVD file.
This can be particularly useful for write-only fields (missing the `read()` function), for which multiple values are written:
```
i2c.CR.init(0)
      .PE().set()
      .SADD(4)
      .write()
```



## Efficiency
I hear you wondering, all those C++ function calls, that must be inefficient, right... right?
Well, if you compile your code without optimizations (`-O0`), then yes.
Also, if you barely do optimizations (`-Og`), then maybe.
However, besides the use case of deep diving into a debug session (which you hopefully not need anymore with this concise interface), any real-world project would be compiled in `-O1` or more.
Note that the assembly emitted by GCC in `-O1`, `-O2`, `-O3`, or `-Os` seems to be identical always, so the links will compile with `-O2`, but I invite you to find a set of compiler options to find a way to reject the arguments listed here, and file a bug report if you find sub-optimal assembly being emitted :).

### Optimal assembly
So, lets put the example given above in [Compiler Explorer](https://godbolt.org/z/ec1esbzGK) and investigate the output.
Don't read the code too much, the first 237 lines are just template code, and will normally be automatically generated by the tool (either SVDConv or svd2cpp) and placed in a separate header file never to be looked at (I challenge you to read all 20401 lines of the SVDConv output for the STM32L552 microcontroller).
The interesting stuff happens in the `i2c_transmit` functions, overloaded for the old school interface and new svd2cpp interface.
Note that both functions are identical to the compiler (but.. the new interface requires a C++ compiler, but hey, if you are one of those ancient lizards still stuck to C only, I would not have expected you would be reading all the way up to this point).

Just to be clear, the ARM processors have an instruction `bfi` for Bit Field Insert, which precisely does the 'Modify' step of the RMW pattern.
They were nice enough to design their processors to be efficient in register access, as they predicted that would be a major use case.
This means that a perfect RMW cycle consists of one 'load' instruction (for Read), one 'bfi' instruction per modify (or similar for `set()` or `clear()`), and one 'store' instruction (for Write).
The total instructions required for the example above would then be 8:

 * Setting thye Peripheral Enable bit is one RMW, 3 instructions
 * Reading the CR register is 1 instruction
 * Modifying the CR register three times is 3 instructions (note that variables are used, if constants would be used they would be optimised to fewer instructions)
 * Writing the CR result is another instruction

Now look again at the assembly view of compiler explorer.
As long as we compile for `-O1` or higher, the output of the svd2cpp interface is always precisely these 8 instructions, nothing more, nothing less.
However, the assembly emitted for the 'old school' interface consists of a baffling 13 instructions, far from perfect!
I have tried other examples where GCC would emit the perfect assembly, however, randomly adding another 'modify' somewhere would mess it up again.
GCC thus seems to be a hit or miss on emitting perfect assembly.

### Clang
Comparing with Clang, unfortunately, Compiler Explorer does not support the Cortex-M family at the time of writing.
However, the same interface works for the Cortex-A family.
Compiler Explorer supports both the ARMv7-A and ARMv8-A family.
Switching the target is as simple as selecting another compiler.
In both thumb and non-thumb mode and both targets, the assembly between the two interfaces is identical, and thus optimal for both.

However.... I also have found an example where clang messes up.
See this new compiler explorer example for [clang](https://godbolt.org/z/s6eP5xx7v).
Here, a RMMW is performed, thus optimal would be to have 4 instructions.
But clang emits a total of 6, where the new svd2cpp interface emits the correct 4 instructions.

Thus, both compilers seem to mess up on a case to case basis.
Please do note that this is not a case against the compilers optimizations, optimizations are hard!
I would not be surprised if you could find a case where the old interface is faster (I challenge you!), since I have not exhausted the complete exploration space.
The point is, efficiency is no reason to NOT use svd2cpp, as it seems to be the most efficient in any case.

### Bit field interface
I hear you asking, and I was wondering as well, the bit field interface should be easy to optimize by GCC/Clang, right?
Well, lo and behold, the [bit field](https://godbolt.org/z/fohGGcGsn) interface in compiler explorer.
Both clang and GCC emit horrible assembly for this interface.
So, although it is much more readable than the define interface, it should not be used when efficiency is important.
Additionally, I have not seen any manufacturer provide the bit field interface out of the box, and if you go and manually export using SVDConv.exe, why not go the extra mile and take this superior C++ interface instead?

## Target platform
Currently, the primary target platform for this library is the Cortex-M processor.
It will probably work on other targets as well, and likely emit perfect assembly, but this has not been thoroughly tested.
Please do let me know if you use it on any other platform, so I can create a list of supported architectures.

## Usage
Of course, a good and easy interface would be worthless if it weren't easy to set up.
Therefore, numerous options are readily available to generate the interface for your set of tools.
I encourage every user of this project to commit additional configurations which may be helpful for other users.

### Binary distribution
Download a pre-generated (Windows) executable to immediately start using svd2cpp.

### Python distribution
Make sure the Python UV dependency manager is installed (`pip install uv`).
Then, in the svd2cpp directory, run `uv run svd2cpp.py {{device_svd}}`, where {{device_svd}} is your svd file.
For example, `uv run svd2cpp.py STM32U595.svd`.

### CMake
Include the CMake script and call the function to automatically generate the interface as part of your build pipeline.

## License & Contribution
While I want to share this idea as much as possible, I would hate that for it to just disappear in the commercial hands and evolve behind closed doors.
Therefore, I decided to share it under the Mozilla Public License, version 2.0 (see LICENSE).
This license enables you to use the code, but if you make any changes or improvements, they must be contributed back (or at least made public).

To contribute to the code, simply make a fork of the project on Github, and open a pull request with your proposed improvements.
This will automatically make the fork visible for anyone interested in this project, who may be interested in your improvement as well.
If I completely agree with the improvement, I will merge the changes in this repository, allowing any user to benefit.


